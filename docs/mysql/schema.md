# Schema设计规范
Schema是数据设计中非常重要的一个部分。在该部分设计中，最好遵循先ER图初步审核，再遵循下面文档约束下，编写文档，输出Schema SQL文件，最好按表分别存放。
## Schema设计的目标
进行Schema设计有两个目标：

1.  更快速的实现业务支撑&数据更好维护
1.  在线上业务压力增大的情况，或是要支撑更大的并发时，知道怎么做能获得最佳的实践。

## Schema设计的原则

1.  尽量小的原则，不浪费
1.  为了高并发，禁止使用外键
1.  每个表必须有主键
1.  字符集和库级保持一致。不单独定义字段字符集。

## 字段规范
* InnoDB表是索引聚集组织表（IOT）， 所有的行数据（row data）都是以主键（严格意义讲，是聚集索引）逻辑顺序存储，而二级索引（或称辅助索引，secondary index）的value则同时包含主键。
* InnoDB的最小I/O单位是data page（默认一个data page大小是16KB），在buffer pool中的最小单位是data page（而不是每行数据哦）。因此也可以这么理解，一个data page里的热点数据越多，其在buffer pool的命中率就会越高。
* MySQL复制环境中，如果binlog format是row的，则从库上的数据更新时是以主键为依据进行apply的，如果没有主键则将可能会有灾难性的后果。
* 强烈建议每张表三个必加字段：aid（int/bigint unsigned类型，自增长列，并且作为主键），create_time（timestamp或int unsigned）、update_time（和create_time相同）用于记录行创建时间以及最后更新时间，在业务上以及日常维护上会有很多便利；

## 字段设计参考 

* 每个表建议不超过30-50个字段
* 优先选择utf8mb4字符集，它的兼容性最好，而且还支持emoji字符。如果对存储容量比较敏感的，可以改成latin1字符集
* 严禁在数据库中明文存储用户密码、身份证、信用卡号（信用卡PIN码）等核心机密数据，务必先行加密
* 存储整型数据时，默认加上UNSIGNED，扩大存储范围
* 建议用INT UNSIGNED存储IPV4地址，查询时再利用INET_ATON()、INET_NTOA()函数转换
* 如果遇到BLOB、TEXT字段，则尽量拆出去，再用主键做关联
* 在够用的前提下，选择尽可能小的字段，用于节省磁盘和内存空间
* 涉及精确金额相关用途时，建议扩大N倍后，全部转成整型存储（例如把分扩大百倍），避免浮点数加减出现不准确问题

## 常用数据类型参考
* 字符类型建议采用varchar数据类型（InnoDB建议用varchar替代char）
* 金额货币科学计数建议采用decimal数据类型，如果运算在数据库中完成可以考虑使用bigint存储，单位：分
* 自增长标识建议采用int或bigint数据类型，如果该表有大量的删除及再写入就使用bigint,反之int就够用
* 时间类型建议采用为datetime/timestamp数据类型
* 禁止使用text、longtext等的数据类型
* 字段值如果为非负数，就加上unsigned定语，提升可用范围

## 主键设计
* 强烈建议使用 INT/BIGINT并且自增做为主键，顺序insert效率更高，表空间碎片率更低
* 主键避免采用字符型，如VARCHAR/CHAR/UUID，会导致原本可以顺序写入的请求变成随机写入，效率更低
* 如果需要用UUID产生一个较大的随机数，则可用uuid_short() 来代替，uuid_short()会生成bigint类型数据
* 拆分时如果需要全局唯一主键，可采用发号器服务、 redis的全局自增，或某个全局DB里统一分配等多种方式生成全局唯一值

## 关于NOTNULL
建议每个字段都设置上NOT NULL属性，可减小存储开销及避免索引失效的问题。 同时，为了避免程序写入失败，还可以增加默认值。如：

```sql
a1 varchar(32) not null default ''

c1 int(10) not null default '0'
```

**特注意**
* count(*) 会统计NULL的行， count(列名） 不会统计此列为NULL值的行
* count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

**旧表新加字段，需要允许为NULL（避免全表数据更新 ，长期持锁导致阻塞）**


## 索引设计

1.  非唯一索引按照“i_字段名称_字段名称[_字段名]”进行命名。

1.  唯一索引按照“u_字段名称_字段名称[_字段名]”进行命名。

1.  索引名称使用小写。

1.  索引中的字段数不超过5个。

1.  唯一键由3个以下字段组成，并且字段都是整形时，使用唯一键作为主键。

1.  没有唯一键或者唯一键不符合5中的条件时，使用自增（或者通过发号器获取）id作为主键。

1.  唯一键不和主键重复。

1.  索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面。

1.  ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面。

1.  单张表的索引数量控制在5个以内，若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。查询性能问题无法解决的，应从产品设计上进行重构。

1.  使用EXPLAIN判断SQL语句是否合理使用索引，尽量避免extra列出现：Using File Sort，Using Temporary。

1.  UPDATE、DELETE语句需要根据WHERE条件添加索引。

1.  对长度大于50的VARCHAR字段建立索引时，按需求恰当的使用前缀索引，或使用其他方法。

1.  下面的表增加一列url_crc32，然后对url_crc32建立索引，减少索引字段的长度，提高效率。

    ```sql
    CREATE TABLE all_url(ID INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,
    url VARCHAR(255) NOT NULL DEFAULT 0,      
    url_crc32 INT UNSIGNED NOT NULL DEFAULT 0,
    index idx_url(url_crc32));
    ```
2. 合理创建联合索引（避免冗余），(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。

1. 合理利用覆盖索引。

## 分库分表

* 分库分表，通常指定表中的一个字段为分区KEY，按Range或是Hash的方式进行拆分。

* 进行分库分表是为了让业务有更好、更快的扩展能力，以适应业务发展需要。同时也方便增删改字段、数据备份恢复等。如果业务稳定，也可以不用进行太多、太复杂的分表方案。服务器性能足够，架构、业务设计也合理的话，MySQL处理上亿数据量的单表也是绰绰有余。

* 单表数据容量限制规则

* 无CHAR/VARCHAR/TEXT/BLOB的可以考虑千万到亿级左右，否则不建议超过千万级别。

* 单表空间物理大小限制规则 ： 业界最佳实践： 单表行数在2000万行或是单表容量超过5G，推荐分库分表，更方便运维及使用。

**备注** 在做分库分表设计时，要考虑后期扩容怎么处理。是通过移动库的形式做扩容，或是通过移动表的形式扩容。是倍数扩容，或是基数扩容，都需要提前规划好。从而设计不同的拆分规则，才能更适用自已的业务。